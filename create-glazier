#!/bin/bash


# defaults. They can be overwritten by command line parameters
verbosity=3  # 1=least verbose, 3=most verbose
dry_run="no"
vmname="testvm"
vmpath="/tmp/.glazier"
productkey=""
use_colors="yes"
windows_iso="/tmp/en_windows_server_2012_r2_with_update_x64_dvd_6052708.iso"
sqlserver_iso="/tmp/en_windows_server_2012_r2_with_update_x64_dvd_6052708.iso"
builder_iso="/bin/bzip2"
virtio_iso="/usr/bin/vi"
profiles=""
sqlserverversion="none"
bridgeadapter="eth0"


# shows the users the script's syntax
function show_help()
{
	cat <<EOF
Syntax: `basename $0` <options>

Available options:
--windows-iso /path/to/windows_iso_kit		- specifies the location of the Windows iso image
--builder-iso /path/to/builder_iso_kit		- specifies the location of the builder iso image
--sql-server-iso /path/to/sqlserver_iso_kit	- specifies the location of the SQLServer iso image
--virtio-iso /path/to/virtio_iso_kit		- specifies the path to the virtio iso image
--profile PATH					- (optional) path to a glazier profile directory.
						  Can be used multiple times
--vm-path PATH					- (optional) path to a directory where VBox files will
						  be saved. The default is ~/.glazier
--with-sql-server {none|2012|2014}		- if this is set, you also have to set --sql-server-iso
--product-key KEY				- Windoes product key
--bridgeadapter					- network interface to bridge to the vm (default:eth0)
--dry-run					- run but don't make any changes
--verbosity verbosity_level			- verbosity level is an interger between 1-3, with 1
						  being the least verbose and 3 being the most verbose
--use-colors {yes|no}				- should the script display colors or not
--help						- shows this message
EOF
}



# sets the appropiate color values based on $use_colors
function set_colors()
{
	if [ "$use_colors" == "yes" ];
	then
		txtred='\e[0;31m' # Red
		txtgrn='\e[0;32m' # Green
		txtylw='\e[0;33m' # Yellow
		txtblu='\e[0;34m' # Blue
		txtpur='\e[0;35m' # Purple
		txtcyn='\e[0;36m' # Cyan
		txtwht='\e[0;37m' # White
		bldblk='\e[1;30m' # Black - Bold
		bldred='\e[1;31m' # Red
		bldgrn='\e[1;32m' # Green
		bldylw='\e[1;33m' # Yellow
		bldblu='\e[1;34m' # Blue
		bldpur='\e[1;35m' # Purple
		bldcyn='\e[1;36m' # Cyan
		bldwht='\e[1;37m' # White
		txtrst='\e[0m'    # Text Reset
	else
		txtred=''
		txtgrn=''
		txtylw=''
		txtblu=''
		txtpur=''
		txtcyn=''
		txtwht=''
		bldblk=''
		bldred=''
		bldgrn=''
		bldylw=''
		bldblu=''
		bldpur=''
		bldcyn=''
		bldwht=''
		txtrst=''
	fi
}



# checks what operating system this is
function get_os()
{
	info 2 "Checking what OS this is"
	os_type=""

	info 3 "Checking if this is a Linux system"
	[ "`uname -s`" == "Linux" ] && os_type="Linux"

	info 3 "Checking if this is an OSX system"
	[ "`uname -s`" == "Darwin" ] && os_type="OSX"


	if [ -z "$os_type" ];
	then
		error 1 "This is neither a Linux nor an OSX operating system. Exiting..."
		exit 1
	fi

	info 3 "Operating system is ${bldylw}${os_type}${txtrst}"
}



# parses the command line parameters
function parse_parameters()
{

	#info 2 "Parsing command line parameters"

	until [ $# -eq 0 ];
	do
		case $1 in
		"--use-colors")
			shift
			use_colors=$1
			set_colors
			shift
			info 3 "Got ${bldylw}use-colors${txtrst} = ${use_colors}"
			;;
		"--verbosity"|"-v")
			shift
			verbosity=$1
			shift
			info 3 "Got verbosity level parameter ${bldylw}${verbosity}${txtrst}"
			;;
		"--windows-iso")
			shift
			windows_iso=$1
			shift
			info 3 "Got ${bldylw}windows-iso${txtrst} = ${windows_iso}"
			;;
		"--sql-server-iso")
			shift
			sqlserver_iso=$1
			shift
			info 3 "Got ${bldylw}sqlserver-iso${txtrst} = ${sqlserver_iso}"
			;;
		"--builder-iso")
			shift
			builder_iso=$1
			shift
			info 3 "Got ${bldylw}builder-iso${txtrst} = ${builder_iso}"
			;;
		"--virtio-iso")
			shift
			virtio_iso=$1
			shift
			info 3 "Got ${bldylw}virtio-iso${txtrst} = ${virtio_iso}"
			;;
		"--help"|"-h")
			show_help
			shift
			exit 0
			;;
		"--dry-run"|"-d")
			shift
			dry_run="yes"
			info 3 "Got ${bldylw}dry-run${txtrst} = ${dry_run}"
			;;
		"--profile"|"-p")
			shift
			profiles="$1 $profiles"
			info 3 "Added profile ${bldylw}$1${txtrst} to profile list"
			shift
			;;
		"--with-sql-server")
			shift
			sqlserverversion=$1
			shift
			if [ "${sqlserverversion}" == "2012" -o "$sqlserverversion" == "2014" -o "${sqlserverversion}" == "none" ];
			then
				info 3 "Using SQLServer version ${bldylw}$sqlserverversion${txtrst}"
			else
				error 1 "Unkown SQLServer version ${sqlserverversion}"
				exit 1
			fi
			;;
		"--vm-path")
			shift
			vmpath=$1
			shift
			info 3 "Got vmpath = $vmpath"
			;;
		"--product-key")
			shift
			productkey=$1
			shift
			info 3 "Got product key"
			;;
		"--bridgeadapter")
			shift
			bridgeadapter=$1
			shift
			info 3 "Got bridgeadapter = ${bridgeadapter}"
			;;
		*)
			error 1 "Unknown parameter $1 ... Exiting"
			exit 1
			;;
		esac
	done
}


# based on which OS we run, create a virtual floppy disk
function create_vfd()
{
#FIXME: this needs testing on both oses
	case "$os_type" in
	"Linux")
		dd if=/dev/zero of=${vmpath}/input/unattend.img
		mkfs.vfat ${vmpath}/input/unattend.img
		;;
	"OSX")
		hdiutil create -megabytes 2 -fs MS-DOS ${vmpath}/input/unattend.img
		;;
	esac
}



# check if we are connected to the Internet
function validate_net_connectivity()
{
	info 2 "Checking Internet connectivity..."
	info 3 "Pinging 8.8.8.8"

	ping -c 3 8.8.8.8 1>/dev/null 2>/dev/null
	local ping_retcode=$?

	if [ ${ping_retcode} -eq 0 ];
	then
		info 3 "We are online"
	else
		error 1 "We are offline"
		exit 1
	fi
}



# check if the script's prerequisites are met
function validate_prerequisites()
{
	info 2 "Checking prerequisites"

	# check if we are root
	info 3 "Checking if we're run as root"
	if [ "`whoami`" != "mcalin" ];
	then
		error 1 "This script needs to be run as root. Exiting..."
		exit 1
	fi

	# check if virtualbox is installed
	info 3 "Checking if virtualbox is installed"
	which virtualbox >/dev/null
	if [ $? -ne 0 ];
	then
		error 1 "virtualbox is not installed. Exiting..."
		exit 1
	fi

	# check if VBoxManage is installed
	info 3 "Checking if VBoxManage is installed"
	which VBoxManage >/dev/null
	if [ $? -ne 0 ];
	then
		error 1 "VBoxManage is not installed. Exiting..."
		exit 1
	fi

	# check if mkfs.vfat is installed
	info 3 "Checking if mkfs.vfat is installed"
	which mkfs.vfat >/dev/null
	if [ $? -ne 0 ];
	then
		error 1 "mkfs.vfat is not installed. Exiting..."
		exit 1
	fi

	# check if windows_iso exists
	info 3 "Checking if Windows iso exists"
	if [ ! -e "${windows_iso}" ];
	then
		error 1 "Cannot find Windows image in : ${windows_iso}"
		exit 1
	else
		info 3 "Found Windows image in : ${windows_iso}"
	fi

	# validate the windows version
	validate_windows_image

	# check if sqlserver_iso exists
	info 3 "Checking if SQLServer iso exists"
	if [ "$sqlserverversion" == "2012" -o "$sqlserverversion" == "2014" ];
	then
		# is --sql-server-iso path defined ?
		if [ -z "$sqlserver_iso" ];
		then
			error 1 "Told to use SQLServer ${bldylw}${sqlserverversion}${txtrst} but no --sql-server-iso path defined"
			exit 1
		fi

		# does the sqlserver iso file exist ?
		if [ ! -e "${sqlserver_iso}" ];
		then
			error 1 "Cannot find SQLServer image in : ${sqlserver_iso}"
			exit 1
		else
			info 3 "Found SQLServer image in : ${sqlserver_iso}"
		fi
	fi

	# check if virtio_iso exists
	info 3 "Checking if virtio iso exists"
	if [ ! -e "${virtio_iso}" ];
	then
		error 1 "Cannot find virtio image in : ${virtio_iso}"
		exit 1
	else
		info 3 "Found virtio image in : ${virtio_iso}"
	fi

	# check if productkey is not empty
	info 3 "Checking Windows product key"
	if [ -z "$productkey" ];
	then
		error 1 "Missing Windows product key"
		exit 1
	fi

	info 3 "Done checking prerequisites"
}



# check if needed environment variables are set, exit if not
function validate_environment_vars()
{
	info 2 "Checking if environment variables are defined"


	info 3 "Checking OS_TENANT_NAME"
	if [ -z ${OS_TENANT_NAME+x} ];
	then
		error 1 "The environment variable ${bldylw}OS_TENANT_NAME${txtrst} is not set. Exiting..."
		exit 1
	fi
	info 3 "${bldylw}OS_TENANT_NAME${txtrst}=$OS_TENANT_NAME"


	info 3 "Checking OS_USERNAME"
	if [ -z ${OS_USERNAME+x} ];
	then
		error 1 "The environment variable ${bldylw}OS_USERNAME${txtrst} is not set. Exiting..."
		exit 1
	fi
	info 3 "${bldylw}OS_USERNAME${txtrst}=$OS_USERNAME"


	info 3 "Checking OS_PASSWORD"
	if [ -z ${OS_PASSWORD+x} ];
	then
		error 1 "The environment variable ${bldylw}OS_PASSWORD${txtrst} is not set. Exiting..."
		exit 1
	fi
	info 3 "${bldylw}OS_PASSWORD${txtrst}=*****"


	info 3 "Checking OS_REGION_NAME"
	if [ -z ${OS_REGION_NAME+x} ];
	then
		error 1 "The environment variable ${bldylw}OS_REGION_NAME${txtrst} is not set. Exiting..."
		exit 1
	fi
	info 3 "${bldylw}OS_REGION_NAME${txtrst}=$OS_REGION_NAME"


	info 3 "Done checking environment variables"
}



# validates the name of the windows image
function validate_windows_image()
{
	# get just the image name, not the full path
	local windows_iso_name=`basename $windows_iso`

	info 2 "Validating Windows iso version"
	if [ -z "`echo $windows_iso_name | grep -i en`" ];
	then
		error 1 "The Windows iso doesen't seem to be an english version. Exiting..."
		exit 1
	fi


	if [ -z "`echo $windows_iso_name | grep 2012`" ];
	then
		error 1 "The Windows iso doesen't seem to be a 2012 version. Exiting..."
		exit 1
	fi


	if [ -z "`echo $windows_iso_name | grep -i x64`" ];
	then
		error 1 "The Windows iso doesen't seem to be a 64bit version. Exiting..."
		exit 1
	fi


	if [ -z "`echo $windows_iso_name | grep -i iso$`" ];
	then
		error 1 "The Windows iso provided doesen't seem to be an iso volume. Exiting..."
		exit 1
	fi

}



# validates a profile's directory structure
function validate_profile()
{
	local profilename=$1

	info 3 "Validating profile ${bldylw}${profilename}${txtrst}"

	if [ ! -e "${profilename}/features.csv" ];
	then
		error 1 "Missing ${profilename}/features.csv file for profile ${bldylw}${profilename}${txtrst}"
		exit 1
	fi


	if [ ! -e "${profilename}/resources.csv" ];
	then
		error 1 "Missing ${profilename}/resources.csv file for profile ${bldylw}${profilename}${txtrst}"
		exit 1
	fi


	if [ ! -d "${profilename}/specialize" ];
	then
		error 1 "Missing ${profilename}/specialize directory for profile ${bldylw}${profilename}${txtrst}"
		exit 1
	fi


	if [ ! -e "${profilename}/specialize/specialize.ps1" ];
	then
		error 1 "Missing ${profilename}/specialize/specialize.ps1 file for profile ${bldylw}${profilename}${txtrst}"
		exit 1
	fi


	if [ ! -e "${profilename}/specialize/tools.csv" ];
	then
		error 1 "Missing ${profilename}/specialize/tools.csv file for profile ${bldylw}${profilename}${txtrst}"
		exit 1
	fi

}


# goes trough all defined profiles and validates each of them
function validate_profiles()
{
	local profile

	for profile in $profiles;
	do
		# validate each profile if its name is not empty
		[ ! -z "$profile" ] && validate_profile $profile
	done
}



# shows a green info message
# Syntax:
# info verbositylevel "message"
# or, you can give the error message as stdin:
# cat file | info verbositylevel
function info()
{
	# get the verbosity of the message
	local info_verbosity=$1
	shift

	# exit the function if the verbosity if greater than the global defined verbosity
	if [ $info_verbosity -gt $verbosity ];
	then
		return 1
	fi

	# we use this later, for stdin parsing
	local outputline

	# check the number of parameters in order to see if the message is comming from stdin or as arguments to the function
	if [ $# -eq 0 ];
	then
		# the message comes from stdin, go trough it and echo it out
		echo -e "`date '+%T %D'`${bldgrn} INFO: ${txtrst}(output follows)"
		while read outputline;
		do
			echo $outputline
		done
	else
		# the message is passed as parameters to the function
		echo -e "`date '+%T %D'`${bldgrn} INFO: ${txtrst}$*"
	fi
}



# shows a red error message
# Syntax:
# error verbositylevel "message"
# or, you can give the error message as stdin:
# cat file | error verbositylevel
function error()
{
	# get the verbosity of the message
	local error_verbosity=$1
	shift

	# exit the function if the verbosity if greater than the global defined verbosity
	if [ $error_verbosity -gt $verbosity ];
	then
		return 1
	fi

	# we use this later, for stdin parsing
	local outputline

	# check the number of parameters in order to see if the message is comming from stdin or as arguments to the function
	if [ $# -eq 0 ];
	then
		# the message comes from stdin, go trough it and echo it out
		echo -e "`date '+%T %D'`${bldred} ERROR: ${txtrst}(output follows)"
		while read outputline;
		do
			echo $outputline
		done
	else
		# the message is passed as parameters to the function
		echo -e "`date '+%T %D'`${bldred} ERROR: ${txtrst}$*"
	fi
}



# runs a parameter specified command and based on the verbosity level, shows or hides the output
# Syntax: run verbositylevel "command with arguments"
function run()
{
	# get the verbosity for the run output
	local run_verbosity=$1
	shift

	# 
	info 1 "Running: \"$*\""

	# is the run verbosity greater than the global one ?
	if [ ${run_verbosity} -gt ${verbosity} ];
	then
		# if not dry_run, run the command and redirect the output to /dev/null
		[ "${dry_run}" != "yes" ] && $* 1>/dev/null
	else
		# if not dry_run, run the command, leave the output on stdout
		[ "${dry_run}" != "yes" ] && $*
	fi
}



# creates the windows image in virtualbox. FIXME: test it
function run_virtualbox()
{

	if [ -e ${vmpath}/vbox/${vmname}/${vmname}.vdi ]
	then
		info 2 "Unregister & delete harddisk"
		vboxmanage closemedium disk ${vmpath}/vbox/${vmname}/${vmname}.vdi --delete
	fi

	info 3 "Create VM and register with VirtualBox"
	run 2 VBoxManage createvm --name ${vmname} --register --ostype Windows2012_64 --basefolder ${vmpath}/vbox

	info 3 "Create disk"
	run 2 VBoxManage createhd --filename ${vmpath}/vbox/${vmname}/${vmname}.vdi --size 25000 --variant standard

	info 3 "Create storage controller (for disk & CDROM)"
	run 2 VBoxManage storagectl ${vmname} --name "IDE" --add ide --controller PIIX4

	info 3 "Attach disk"
	run 2 VBoxManage storageattach ${vmname} --storagectl "IDE" --port 0 --device 1 --type hdd --medium  ${vmpath}/vbox/${vmname}/${vmname}.vdi

	info 3 "Create floppy controller"
	run 2 VBoxManage storagectl ${vmname} --name "Floppy" --add floppy

	info 3 "Attach unattend.img to floppy controller"
	run 2 VBoxManage storageattach ${vmname} --storagectl "Floppy" --port 0 --device 0 --type fdd --medium ${vmpath}/unattend.img

	info 3 "Create storage controller (for disk & CDROM)"
	run 2 VBoxManage storagectl ${vmname} --name "SATA" --add sata --controller IntelAHCI --portcount 4

	info 3 "Attach ISO to DVD"
	run 2 VBoxManage storageattach ${vmname} --storagectl "SATA" --port 0 --type dvddrive --medium ${windows_iso}
	run 2 VBoxManage storageattach ${vmname} --storagectl "SATA" --port 1 --type dvddrive --medium ${builder_iso}
	run 2 VBoxManage storageattach ${vmname} --storagectl "SATA" --port 2 --type dvddrive --medium ${virtio_iso}

	run 2 VBoxManage sharedfolder add ${vmname} --name output --hostpath ${vmpath}/output --automount

	run 2 VBoxManage modifyvm ${vmname} --boot1 dvd
	run 2 VBoxManage modifyvm ${vmname} --boot2 disk
	run 2 VBoxManage modifyvm ${vmname} --boot3 none
	run 2 VBoxManage modifyvm ${vmname} --boot4 none

	info 3 "Bridging eth0 to the virtual machine's network adapter"
	run 2 VBoxManage modifyvm ${vmname} --nic1 bridged --cableconnected1 on --bridgeadapter1 ${bridgeadapter}
	run 2 VBoxManage modifyvm ${vmname} --memory 4096
	run 2 VBoxManage modifyvm ${vmname} --clipboard bidirectional

	run 2 VBoxManage startvm ${vmname}

	#run 2 VBoxManage guestcontrol  ${vmname} updateadditions --source /Applications/VirtualBox.app/Contents/MacOS/VBoxGuestAdditions.iso --verbose

}

parse_parameters $*
set_colors
get_os
validate_environment_vars
validate_net_connectivity
validate_prerequisites
validate_profiles
#run_virtualbox

